Consider filtering redundant calls to onSecurityChange
Johnathan and I have noticed that onSecurityChange seems to be called rather frequently during "normal" page loads, even though the security state hasn't changed in a noticeable way. This makes us update browser chrome elements more than we need to, which has an impact on page load times.

As an experiment, I tried caching the current URI, the "state" parameter to onSecurityChange, and the "SSLStatus" object, and returned early from the main browser window's onSecurityChange if they hadn't changed since the last call. When running a patch with this changed applied through the Tp pageset (40 pages visited 5 times each, all non-SSL), I observed a total of ~600 calls to onSecurityChange, ~400 of which returned early due to the change I made.

From reading the comment at http://bonsai.mozilla.org/cvsblame.cgi?file=mozilla/security/manager/boot/src/nsSecureBrowserUIImpl.cpp&rev=1.65#518 it seems to me that the backend code that fires onSecurityChange must deal with a large number of edge cases (frames, subelements, etc) and therefore errs on the side of caution, firing onSecurityChange in cases where it can't be sure that something hasn't changed. Given that we know exactly what information the browser code uses to update it's security UI, we should be able to avoid redundant UI updates by ignoring onSecurityChange notifications when that information hasn't changed.

Another question is whether this filtering should be done at a lower level than the browser front end code. We could perhaps do it in the browser status filter (nsBrowserStatusFilter) and share the benefit with other users of that class (i.e. SeaMonkey). It may also be possible to reduce the frequency of these notifications at the source (PSM code), but I fear that change code at that low of a level introduces more regression risk given the potential impacts on other consumers.