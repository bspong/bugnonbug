Consider filtering redundant call to onSecurityChange
Johnathan and I have noticed that onSecurityChange seems to be called rather frequently during "normal" page loads, even though the security state hasn't changed in a noticeable way. This make u update browser chrome element more than we need to, which ha an impact on page load times.

As an experiment, I tried caching the current URI, the "state" parameter to onSecurityChange, and the "SSLStatus" object, and returned early from the main browser window's onSecurityChange if they hadn't changed since the last call. When running a patch with this changed applied through the Tp pageset (40 page visited 5 time each, all non-SSL), I observed a total of ~600 call to onSecurityChange, ~400 of which returned early due to the change I made.

From reading the comment at http://bonsai.mozilla.org/cvsblame.cgi?file=mozilla/security/manager/boot/src/nsSecureBrowserUIImpl.cpp&rev=1.65#518 it seems to me that the backend code that fire onSecurityChange must deal with a large number of edge case (frames, subelements, etc) and therefore errs on the side of caution, firing onSecurityChange in case where it can't be sure that something hasn't changed. Given that we know exactly what information the browser code us to update it's security UI, we should be able to avoid redundant UI update by ignoring onSecurityChange notification when that information hasn't changed.

Another question is whether this filtering should be done at a lower level than the browser front end code. We could perhaps do it in the browser status filter (nsBrowserStatusFilter) and share the benefit with other user of that class (i.e. SeaMonkey). It may also be possible to reduce the frequency of these notification at the source (PSM code), but I fear that change code at that low of a level introduces more regression risk given the potential impact on other consumers.
